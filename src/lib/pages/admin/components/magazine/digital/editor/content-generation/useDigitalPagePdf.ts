'use client';

/**
 * useDigitalPagePdf - PDF generation hook for Digital Page Editor
 *
 * Accepts canvas data URL directly instead of re-capturing.
 * This ensures the PDF matches EXACTLY what is shown in the preview.
 *
 * The preview is already generated by useCanvasPreview at exact PDF dimensions.
 * We simply load that data URL and add it to the PDF at full size (no margin).
 */

import { useState, useCallback } from 'react';
import { jsPDF } from 'jspdf';
import type { PagePdfSettings, PdfGenerationResult } from '../types';

// Import from shared utilities
import { getPdfDimensions, loadImage, fetchImageAsBase64 } from './shared';

// =============================================================================
// TYPES
// =============================================================================

/**
 * Return type for useDigitalPagePdf hook
 */
export interface UseDigitalPagePdfReturn {
  generatePdf: (
    canvasDataUrl: string,
    fileName: string,
    pdfSettings: PagePdfSettings
  ) => Promise<PdfGenerationResult>;
  isGenerating: boolean;
  progress: string;
  error: string | null;
}

// =============================================================================
// HOOK IMPLEMENTATION
// =============================================================================

export function useDigitalPagePdf(): UseDigitalPagePdfReturn {
  const [isGenerating, setIsGenerating] = useState(false);
  const [progress, setProgress] = useState('');
  const [error, setError] = useState<string | null>(null);

  const generatePdf = useCallback(
    async (
      canvasDataUrl: string,
      fileName: string,
      pdfSettings: PagePdfSettings
    ): Promise<PdfGenerationResult> => {
      setIsGenerating(true);
      setError(null);
      setProgress('Preparing PDF...');

      try {
        // Validate input - must have some URL
        if (!canvasDataUrl) {
          throw new Error('No canvas image provided. Generate a preview first.');
        }

        // Get PDF dimensions in mm
        const dimensions = getPdfDimensions(pdfSettings);
        const { width: pdfWidthMm, height: pdfHeightMm } = dimensions;

        // Determine image data - convert Firebase URLs to base64
        let imageData: string = canvasDataUrl;

        if (canvasDataUrl.startsWith('data:')) {
          // Already a data URL, use directly
          setProgress('Loading preview image...');
          await loadImage(canvasDataUrl);
        } else if (canvasDataUrl.startsWith('https://')) {
          // Firebase Storage URL - fetch and convert to base64
          setProgress('Loading image from storage...');
          imageData = await fetchImageAsBase64(canvasDataUrl);
        } else {
          throw new Error('Invalid image format. Expected data URL or Firebase Storage URL.');
        }

        setProgress('Creating PDF...');

        // Create PDF with correct dimensions
        const orientation = pdfWidthMm > pdfHeightMm ? 'landscape' : 'portrait';
        const pdf = new jsPDF({
          orientation,
          unit: 'mm',
          format: [pdfWidthMm, pdfHeightMm],
        });

        // Add canvas image to PDF at FULL SIZE (0, 0 position, full page dimensions)
        // The imageData contains the correctly rendered content at PDF dimensions
        // No margin - content fills entire page (full bleed)
        pdf.addImage(
          imageData,
          'PNG',
          0,              // x position
          0,              // y position
          pdfWidthMm,     // width (full page width)
          pdfHeightMm     // height (full page height)
        );

        // Add clickable link for website URL if footer is enabled
        if (pdfSettings.footer?.enabled && pdfSettings.footer?.showWebsiteUrl) {
          const footerSettings = pdfSettings.footer;
          const marginBottomMm = footerSettings.marginBottom || 10;
          const fontSize = footerSettings.fontSize || 10;
          const linkText = 'glamlink.net';
          const linkUrl = 'https://glamlink.net';

          // Set font to calculate text width
          pdf.setFontSize(fontSize);
          const textWidth = pdf.getTextWidth(linkText);

          // Calculate link position based on alignment
          // Footer uses 6mm padding (px-6 at ~24px â‰ˆ 6mm)
          const paddingMm = 6;
          const yPos = pdfHeightMm - marginBottomMm;

          let xPos: number;
          if (footerSettings.websiteUrlAlignment === 'left') {
            // Left aligned - after other left-aligned elements
            // For simplicity, place at left padding
            xPos = paddingMm;
          } else {
            // Right aligned - at the right edge minus padding and text width
            xPos = pdfWidthMm - paddingMm - textWidth;
          }

          // Add clickable link annotation
          // The link sits on top of the rendered footer text
          // y position is adjusted for font height (font ascender)
          const linkHeight = fontSize * 0.4; // Approximate mm height for font
          pdf.link(xPos, yPos - linkHeight, textWidth, linkHeight * 1.5, { url: linkUrl });
        }

        setProgress('Saving PDF...');

        // Save PDF
        const finalFileName = fileName.endsWith('.pdf') ? fileName : `${fileName}.pdf`;
        pdf.save(finalFileName);

        setProgress('Complete!');
        setIsGenerating(false);

        return {
          success: true,
          fileName: finalFileName,
        };
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';
        console.error('PDF generation error:', err);
        setError(errorMessage);
        setIsGenerating(false);
        setProgress('');

        return {
          success: false,
          error: errorMessage,
        };
      }
    },
    []
  );

  return {
    generatePdf,
    isGenerating,
    progress,
    error,
  };
}

export default useDigitalPagePdf;
